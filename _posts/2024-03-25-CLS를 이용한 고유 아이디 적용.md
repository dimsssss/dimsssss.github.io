---
title:  "CLS를 이용한 고유 아이디 적용"
date: 2024-03-25T00:39:45+09:00
categories: 
    - 프로그래밍
tags:
    - nodejs
    - cls
---

사이드 프로젝트를 오픈한 지 약 두 달 정도 되어간다. 최근에는 유저들이 가입 할때마다 알림을 받고 싶다는 요청이 있었고(총 가입자수와 함께) 유저의 요청 사항을 저장하는 API 그리고 요청 사항이 올때마다 메일로 받고 싶다는 요청이 있었다. 팀 채널로 discord를 사용하고 있었고 webhook을 이용하여 알림을 받기로 하였다. 

이번 작업은 동기로 처리할 필요가 없었기 때문에 메세지 큐를 이용하여 처리를 하였다. 유저 문의를 받는 API를 만들고 어드민 계정으로 문의 내용을 메일로 보냈다. 어드민 계정으로만 메일을 보내기 때문에 SNS 대신 SQS 하나로 처리를 하였다.

처음에는 순조로웠다. 예상대로 문의가 들어오면 관리자 계정으로 관련 메일이왔다. 연속으로 문의를 보냈을 때 이상한 점을 발견하였는데 처음에 들어온 메세지만 SQS에 쌓이고 다음 메세지는 자동으로 제거되었다. 그리고 몇 분 후에 다시 API를 호출하면 메세지가 큐에 쌓였다. 이 과정이
반복되었다.
원인을 찾기 위해서 먼저 SQS(fifo queue)에 설정들을 살펴보았는데 콘텐츠 기반 중복 제거가 활성화되어있었다. 이게 관련이 있을 것 같았는데 이유는 연속으로 테스트로 보낸 메세지가 비슷한 텍스트였기 때문이다.

`메세지1`
```json
{
	"type": "신고",
	"content": "어그로 너무 심한 유저들이 있습니다"
}
```

`메세지2`
```json
{
	"type": "신고",
	"content": "어그로 너무 심한 유저들이 있습니다!!"
}
```

그리고 aws-sdk에 deduplicatedId라는 값이 있었는데 콘텐츠 기반 중복 제거가 활성화되어 있으면 optional이었다. [관련 문서](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/using-messagededuplicationid-property.html)를 찾아보니 AWS SQS(fifo)는 중복을 제거하기 위해서 messageId를 갖는데 메세지가 도착하면 queue에 쌓인 메세지 id를 비교해서 중복을 제거한다(5분동안). 그래서 5분 간격으로 SQS에 메세지가 쌓였던 것이다.

그러면 어떤 값을 deduplicatedId에 넣어야 할까? 하는 고민을 하니 이제서야 왜 uuid를 사용하고 데이터베이스 테이블에 key를 uuid로 사용하면 좋은지(물론 이 용도로 설정하는 것은 아니지만). 나는 서버에서 따로 uuid를 사용하지 않는다. 그러면 데이터베이스 key를 사용해야 하는데 key가 숫자(Auto Increment)라면 중복될 가능성이 발생한다.

물론 이 방법은 문제가 있다.
- 데이터베이스에서 생성하지 않으면 사용할 수가 없다. 
- 데이터베이스의 데이터가 삭제되면 추적이 불가능해진다. 
- 데이터베이스에 장애가 발생하면 메세지 큐도 예상하지 못한 동작을 할 수 있다
이때는 먼저 database에서 생성한 uuid를 키로 사용하였다

## 장애 알림
회원 가입하면 총 가입자 수와 함께 알림이 제대로 오는지 확인하기 위해서 직접 회원을 탈퇴하고 가입을 해보았다. 이 서비스는 회원 가입을 할 때 마지막으로 좋아하는 아티스트를 선택할 수 있다. 여기서 내가 충격을 받았는데 첫번째로 프론트 쪽 버그로 아티스트를 선택할 수 없었다. 두 번째로는 서버쪽 문제로 선택을 안하고 회원 가입을 하면 서버에서 에러를 뱉고 가입이 안되는 상황이 발생하였다. 즉 회원 가입이 안되는 상황이었다.

내 실수로 회원 가입이 안되었던 미안함(팀원들의 하루 방문자 100을 보고 웃고 있던 얼굴이 오버랩 되면서), 에러가 발생을 해도 몰랐던 것에 대한 멍청함 그리고 사용자들은 자동으로 회원 가입을 할 수 없는 상황으로 가는 것들이 동시에 떠오르면서 안타까웠다.

그래서 이것을 해결하기 위해서 서버에서 발생하는 모든 에러를 알림으로 받으면 표면적으로 발생하는 장애들은 대처할 수 있다라는 생각을 하였다.

프로세스는 회원 가입 알림과 비슷했다. 다만 조금 더 개선하기 위해서 장애들을 하나의 묶음으로 디버깅을 할 수 있어야한다는 생각이 들었다. 예를 들어 하나의 요청이 오면 발생할 수 있는 에러들이 많은데 관련된 에러를 묶어서 봐야 장애를 해결하는데 도움이 될 것 같았고 이게 없다면 에러가 여러 번 났을 경우 로그에서 에러마다 관련있는 내용을 직접 필터링하면서 봐야하는 번거로움이 발생한다.

그래서 하나의 요청이 오면 requestId를 생성하고 이 아이디를 그룹 아이디로 사용하여 관련된 에러를 하위로 묶는다.

### CLS
다른 언어(multi thread)들은 requestId를 어떻게 관리할까? 리서치를 해보면 주로 thread local storage를 사용한다. request가 올때마다 하나의 스레드를 생성해서 처리하기 때문에 스레드 마다 내부에 고유의 아이디를 부여한다. 스레드 내부가 아닌 일반 객체에 아이디를 저장하면 멀티 스레드 특성 때문에 저장했던 아이디가 바뀔 수 있기 때문이다.

그러나 nodejs는 싱글스레드이기 때문에 스레드 내부에 아이디를 저장해도 소용이 없다. 예를 들어 request가 계속와도 같은 스레드에서 처리하기 때문이다. 이것을 해결하기 위해 CLS라는 모듈을 사용하는데 context라는 객체를 생성해서 저장하는 기법이다. 즉 멀티 스레드에서 사용하는 thread local storage에 해당하는 것이다.

여러 웹 프레임워크에 맞춤 용도로 만들어진 cls 모듈이 존재한다. nestjs용으로 공식 문서에 소개되어있다
https://docs.nestjs.com/recipes/async-local-storage

동일한 traceId가 적용되었다
![](https://i.imgur.com/qQwuIGa.png)

![](https://i.imgur.com/TpWM5E7.png)
