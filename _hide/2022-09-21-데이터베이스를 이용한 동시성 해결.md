---
title:  "데이터베이스를 이용한 동시성 해결"
date: 2022-09-21T00:39:45+09:00
categories: 
    - 동시성 문제
tags:
    - 데이터베이스
    - redis
    - mysql
---

이 글은 회사 채용 과제에서 동시성 이슈를 어떻게 해결했는지 더 나은 방안은 없었는지 정리한 글이다. 채용 과제의 대략적인 내용은 다음과 같다.

`보스 raid를 진행하는 API를 개발하세요.`
- 처음 신청한 유저에게 보스를 레이드할 기회를 얻습니다.
- 그 사이에 어떠한 유저도 보스를 레이드할 수 없습니다.
- 레이드 시간은 3분입니다. 3분이 지나면 다시 보스를 레이드할 수 있습니다.
- 3분 동안 레이드 결과가 오지 않으면 자동으로 레이드는 실패로 간주합니다.
- 랭킹을 API를 구현하세요

> *레이드: 보스를 쓰러트리는 게임 용어

구현하면서 크게 두 가지 문제를 해결하였다.
## 동시에 여러명이 요청할 경우
처리 로직은 다음과 같다.
1. DB에 저장된 보스의 상태를 확인한다
2. 레이드 가능하면 상태를 변경하고 클라이언트에 http status 200을 보낸다
3. 레이드 불가능하면 클라이언트에 http status 400을 보낸다.

여기서 문제는 1번을 처리할 때 찰나의 시간 차로 2개 이상의 요청이 오면 요청 모두 보스를 레이드하게 된다. 이러한 문제를 해결하기 위해서 ORM에서 지원하는 낙관적 락을 적용하려고 하였다.
### 낙관적 락
데이터베이스에서 두 개의 트랜잭션이 동일한 데이터 또는 테이블을 대상으로 쿼리를 작업할 때 이상 현상이 발생할 수 있다. 이를 방지하기 위해서 특정한 모드를 지정하는데, 트랜잭션 isolation level이라고도 한다. 잠금을 사용하기 때문에 위의 레벨로 올라갈수록 안정성은 높아지지만 성능은 낮아진다.

성능 문제를 해결하기 위해 MVCC라는 개념을 적용하는데 데이터가 변경되는 쿼리가 실행될 때마다 데이터의 이전 버전을 저장해서 잠금 없이 쿼리를 실행하게 하는 기법이다. 여기서 만약 하나의 데이터에 동시에 수정을 하게 되면 먼저 수정된 버전만 반영이 되고 나중에 수정된 버전은 취소가 된다. 이 부분을 ORM에서 처리를 해주는데 낙관적 락을 사용한다고 말한다.

내가 사용하는 ORM을 이용하여 문제를 해결하려고 하였지만 ORM이 뜻대로 동작하지 않았다.(예외를 발생시키지 않았다)
https://github.com/sequelize/sequelize/issues/7831

### 명시적 잠금 사용
mysql에서는 `for update` 라는 키워드를 select와 같이 사용하면 해당 데이터를 잠글 수 있다. 트랜잭션을 시작하고 boss 데이터에 먼저 접근을 하자마자 해당 데이터를 잠그고 상태를 변경하였다.

![](https://i.imgur.com/g9TouMV.png)

![](https://i.imgur.com/gSgyqqh.png)


## 랭킹 구현
보스 레이드를 성공할 때마다 점수를 얻게 되는데 점수를 기반으로 랭킹을 반환해야 했다. mysql에서 제공하는 함수를 사용해서 rank를 구했다.
https://dev.mysql.com/doc/refman/8.3/en/window-function-descriptions.html#function_rank
### Redis Sorted  Set
mysql을 이용해서 ranking을 구할 때 단점은 데이터가 많아질수록 처리량이 많아진다. 극단적으로 데이터가 100만개가 있다면 100만개를 유저별로 분류하고, 합계를 내고, 합계 기반으로 순위를 매겨야한다. 현실적으로는 어떤 게임에서도 보스 레이드를 많이 해도 100번은 힘들다. 거기다가 보스 레이드는 순차적으로 진행할 수 있기에 그만큼 데이터가 많아질 경우가 거의 없다. 결국 RDB만으로 구현을 하는데 문제는 없지만 더 좋은 방법은 없을까 고민을 해보았고 redis를 이용하면 좋을 것 같았다(여기서는 redis에 대한 설명은 생략한다)

Redis에서 제공하는 기능 가운데 sorted set이라는 데이터 구조가 있는데 데이터를 추가하거나 수정할 때마다 순위를 자동으로 바꿔준다. 데이터를 추가하거나 조회할 때도 `O(log(n))` 의 성능을 보장한다
